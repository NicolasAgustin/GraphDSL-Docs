\documentclass{article}
\title{GraphDSL Documentacion}
\author{Nicolas Sandez}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\begin{document}

    \definecolor{dkgreen}{rgb}{0,0.6,0}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{mauve}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}

    \newcommand{\itb}[1]{\textbf{\textit{#1}}}
    \newcommand{\bd}[1]{\textbf{#1}}

    \lstset{
            backgroundcolor=\color{backcolour},
            frame=tb,
            language=Python,
            aboveskip=3mm,
            belowskip=3mm,
            showstringspaces=false,
            columns=flexible,
            basicstyle={\small\ttfamily},
            numbers=none,
            numberstyle=\tiny\color{gray},
            keywordstyle=\color{blue},
            commentstyle=\color{dkgreen},
            stringstyle=\color{mauve},
            breaklines=true,
            breakatwhitespace=true,
            tabsize=3
    }

    \lstset{language=Python}

	\pagenumbering{arabic}

	\maketitle
	\newpage
	
	
	\tableofcontents
	\newpage
	
	% \begin{equation*}
	% 	f(x) = x^2
	% \end{equation*}
	\section{Propuesta}
	El proyecto consiste en un lenguaje especifico de dominio para la generación de diagramas de
grafos en LaTeX. Dicho lenguaje, que lo llamaremos GraphDSL, cuenta con bucles, salida por
pantalla, condicionales, variables enteras y cadenas de caracteres.
	\section{Propiedades}
	El lenguaje soporta los tipos de datos: Enteros y Strings. A continuacion se detallan las operaciones disponibles para cada uno.
	\subsection{Enteros}
	\begin{itemize}
		\item Suma
		\item Resta
		\item División
		\item Multiplicación
		\item Igual que
		\item Menor
		\item Mayor
		\item Menor o igual
		\item Mayor o igual
		\item Distinto
		\item Casteo a string
	\end{itemize}
	\subsection{String}
	\begin{itemize}
		\item Concatenación
	    \item Longitud
	    \item Casteo a entero
	\end{itemize}
    \subsection{Nodos}
    Si bien no es posible definir un tipo de dato nodo por parte del usuario, 
    internamente son representados por un tipo de dato Nodo, el cual tiene las siguientes operaciones:
    \begin{itemize}
       \item{$\rightarrow$ Arista dirigida hacia la derecha.}
       \item{$\leftarrow$ Arista dirigida hacia la izquierda.}
       \item{$\leftrightarrow$ Arista bidireccional.}
       \item Color de nodo.
    \end{itemize}
    \subsection{Implementacion}
    Internamente el lenguaje opera como una matriz, donde cada nodo estara posicionado en una coordenada especifica.
    El tamaño de la matriz sera definido por el usuario y cada vez que se desee insertar un nodo a al grafo se debe
    especificar en que fila y columna colocarlo.
    \subsection{Colores}
    Tanto los nodos como las aristas permiten establecer el color de las mismas. Los colores disponibles son:
    \begin{itemize}
        \color{red}
        \item red
        \color{blue}
        \item blue
        \color{green}
        \item green
        \color{yellow}
        \item yellow
        \color{black}
        \item black
        \color{black}
        \item white
        \color{brown}
        \item brown
        \color{purple}
        \item purple
        \color{gray}
        \item grey
        \color{orange}
        \item orange
        \color{pink}
        \item pink
    \end{itemize}

    \newpage
    \section{Funciones nativas}
    \subsection{len}
    La funcion len devuelve la longitud de una cadena de caracteres.
    \begin{align} 
        \itb{len}( \itb{strexp} ) \rightarrow \itb{int}
    \end{align}
    \begin{lstlisting}
        # Longitud de una cadena
        string cadena = "ejemplo";
        int longitud = len(cadena)
    \end{lstlisting}
    \subsection{int}
    La funcion int devuelve la representacion numerica de una cadena de caracteres.
    \begin{align} 
        \itb{int}( \itb{strexp} ) \rightarrow \itb{int}
    \end{align}
    \begin{lstlisting}
        # Casteo de string a int
        string cadena = "10";
        int numero = int(cadena)
    \end{lstlisting}
    \subsection{str}
    La funcion str convierte un entero a cadena de caracteres.
    \begin{align} 
        \itb{str} ( \itb{intexp} ) \rightarrow \itb{string}
    \end{align}
    \begin{lstlisting}
        # Casteo de int a string
        int numero = 10;
        string cadena = "El numero es: " & str(numero) 
    \end{lstlisting}
    \subsection{log}
    La funcion log logea una string a un archivo "logger.lg".
    \begin{align} 
        \itb{log} ( \itb{strexp} )
    \end{align}
    \begin{lstlisting}
        # Logging
        int contador = 10;
        log("Loggeando... " & str(numero)) 
    \end{lstlisting}
    \section{Sintaxis de superficie}
    \subsection{Condicional}
    La clausula \textbf{else} es opcional. \par
    \begin{center}
        \itb{if} ( \itb{boolexp} ) 
        \{ \itb{cmd} \} \itb{else} \{ \itb{cmd} \}
    \end{center}
    \begin{lstlisting}
        # Condicionales
        int edad = 20;
        if (edad > 18) {
            log("Puede beber!")
        } else {
            log("No puede beber!")
        }
    \end{lstlisting}
    \subsection{Bucles}
    En este caso contamos con bucles while y for.\par
    \begin{center}
        \itb{while} (\itb{boolexp}) \{\itb{cmd}\}
    \end{center}
    \begin{lstlisting}
        # Bucle while
        int counter = 0;
        int veces = 5;
        
        while (counter < veces) {
            counter = counter + 1
        }

    \end{lstlisting}
    \begin{center}
        \itb{for} (\itb{intexp} to \itb{intexp}) \{\itb{cmd}\}
    \end{center}
    \begin{lstlisting}
        # Bucle for
        int counter = 0;
        int veces = 5;
        
        while (0 to veces) {
            counter = counter + 1
        }

    \end{lstlisting}
    \newpage
    \subsection{Definicion y asignacion de variables}
    Podemos definir variables del tipo string e int.\par
    \begin{center}
        \itb{int} \itb{var} = \itb{intexp}
    \end{center}
    \begin{center}
        \itb{string} \itb{var} = \itb{strexp}
    \end{center}
    \begin{lstlisting}
        # Asignaciones
        int numero = 15;
        string saludo = "Buenos dias";
        numero = numero * 2;
        saludo = "Buenas noches"
    \end{lstlisting}

    \subsection{Operadores}
    Los operadores para expresiones enteras son multiplicacion, division, suma, resta y modulo respectivamente.
    \begin{center}
        \itb{intexp} $\left[*|/|+|-|\%\right]$ \itb{intexp}
    \end{center}
    El operador para expresiones string es el concatenacion.
    \begin{center}
        \itb{strexp} \& \itb{strexp}
    \end{center}

    \subsection{Grafos}
    La sentencia Graph indica que se creara un archivo de salida con un nombre especificado por el usuario. 
    \begin{center}
        \itb{GRAPH}(\itb{strexp}, \itb{intexp})$\left[\itb{intexp}\right]$
            \begin{center} \itb{cmd} \end{center}
        \itb{END}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \end{center}

    \itb{Nombre} indica, valga la redundancia, el nombre del archivo de output, \itb{size} establece la distancia entre nodos y
    \itb{msize} establece las dimensiones de la matriz interna donde se posicionan los nodos, por ejemplo, \itb{msize=4} establecera
    una matriz interna de 4x4. \par
    \begin{center}
        \itb{GRAPH}(\itb{nombre}, \itb{size})$\left[\itb{msize}\right]$
    \end{center}

    \begin{lstlisting}
        # Grafos
        string nombre = "grafo1";
        # Crea un grafo con una matriz interna de 3x3
        GRAPH(nombre, 5)[3]
            ...
        END 
    \end{lstlisting}

    \subsection{Nodos y aristas}
    \bd{GraphDSL} permite la creacion de nodos, estableciendo su identificador (tag) y en que fila y columna insertarlo 
    en la matriz interna.
    \begin{center}
        \itb{node}\{\itb{strexp}\}$<$\itb{intexp},\itb{intexp}$>$
    \end{center}
    \begin{lstlisting}
        string nombre = "";
        int max = 2;
        int counter = 0;
        int fila = 0;
        int columna = 0;
        GRAPH("test", 5)[max]
            while (fila < max) {
                while (columna < max){
                    # Construimos el id del nodo
                    nombre = "n" & str(counter);
                    # Insertamos el nodo en la matriz
                    node {nombre}<fila,columna>;
                    counter = counter + 1;
                    columna = columna + 1
                };
                # Reseteamos el contador de columnas
                columna = 0;
                fila = fila + 1
            }
        END
    \end{lstlisting}


\end{document}
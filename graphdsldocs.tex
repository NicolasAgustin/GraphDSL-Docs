\documentclass{article}
\title{GraphDSL}
\author{Nicolás Sandez, Dardo Eloy}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\begin{document}

    \definecolor{dkgreen}{rgb}{0,0.6,0}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{mauve}{rgb}{0.58,0,0.82}
    \definecolor{backcolour}{rgb}{0.95,0.95,0.92}

    \newcommand{\itb}[1]{\textbf{\textit{#1}}}
    \newcommand{\bd}[1]{\textbf{#1}}
    \newcommand{\curly}{\mathrel{\leadsto}}

    \lstset{
            backgroundcolor=\color{backcolour},
            frame=tb,
            language=Python,
            aboveskip=3mm,
            belowskip=3mm,
            showstringspaces=false,
            columns=flexible,
            basicstyle={\small\ttfamily},
            numbers=none,
            numberstyle=\tiny\color{gray},
            keywordstyle=\color{blue},
            commentstyle=\color{dkgreen},
            stringstyle=\color{mauve},
            breaklines=true,
            breakatwhitespace=true,
            tabsize=3
    }

    \lstset{language=Python}

	\pagenumbering{arabic}

	\maketitle
	\newpage
	
	
	\tableofcontents
	\newpage
	
	% \begin{equation*}
	% 	f(x) = x^2
	% \end{equation*}
	\section{Propuesta}
	El proyecto consiste en un lenguaje específico de dominio para la generación de diagramas de
grafos en LaTeX. Dicho lenguaje, que lo llamaremos GraphDSL, cuenta con bucles, condicionales, variables enteras y cadenas de caracteres.
	\section{Propiedades}
	El lenguaje soporta los tipos de datos: Enteros y Strings. A continuación se detallan las operaciones disponibles para cada uno.
	\subsection{Enteros}
	\begin{itemize}
		\item Suma
		\item Resta
		\item División
		\item Multiplicación
		\item Igual que
		\item Menor
		\item Mayor
		\item Menor o igual
		\item Mayor o igual
		\item Distinto
		\item Casteo a string
	\end{itemize}
	\subsection{String}
	\begin{itemize}
		\item Concatenación
	    \item Lóngitud
	    \item Casteo a entero
	\end{itemize}
    \subsection{Nodos}
    Si bien no es posible definir un tipo de dato nodo por parte del usuario, 
    internamente son representados por un tipo de dato Nodo. El cual tiene las siguientes operaciones:
    \begin{itemize}
       \item{$\rightarrow$ Arista dirigida hacia la derecha.}
       \item{$\leftarrow$ Arista dirigida hacia la izquierda.}
       \item{$\leftrightarrow$ Arista bidireccional.}
       \item Color de nodo.
    \end{itemize}
    \subsection{Implementación}
    Internamente el lenguaje opera como una matriz, donde cada nodo estará posicionado en una coordenada específica.
    El tamaño de la matriz sera definido por el usuario y cada vez que se desee insertar un nodo al grafo se debe
    especificar en que fila y columna colocarlo.
    \subsection{Colores}
    Tanto los nodos como las aristas permiten establecer el color de las mismas. Los colores disponibles son:
    \begin{itemize}
        \color{red}
        \item red
        \color{blue}
        \item blue
        \color{green}
        \item green
        \color{yellow}
        \item yellow
        \color{black}
        \item black
        \color{black}
        \item white
        \color{brown}
        \item brown
        \color{purple}
        \item purple
        \color{gray}
        \item grey
        \color{orange}
        \item orange
        \color{pink}
        \item pink
    \end{itemize}

    \newpage
    \section{Funciones nativas}
    \subsection{len}
    La función len devuelve la lóngitud de una cadena de caracteres.
    \begin{align} 
        \itb{len}( \itb{strexp} ) \rightarrow \itb{int}
    \end{align}
    \begin{lstlisting}
        # Lóngitud de una cadena
        string cadena = "ejemplo";
        int lóngitud = len(cadena)
    \end{lstlisting}
    \subsection{int}
    La función int devuelve la representación numérica de una cadena de caracteres.
    \begin{align} 
        \itb{int}( \itb{strexp} ) \rightarrow \itb{int}
    \end{align}
    \begin{lstlisting}
        # Casteo de string a int
        string cadena = "10";
        int numero = int(cadena)
    \end{lstlisting}
    \subsection{str}
    La función str convierte un entero a cadena de caracteres.
    \begin{align} 
        \itb{str} ( \itb{intexp} ) \rightarrow \itb{string}
    \end{align}
    \begin{lstlisting}
        # Casteo de int a string
        int numero = 10;
        string cadena = "El numero es: " & str(numero) 
    \end{lstlisting}
    \subsection{log}
    La función log logea una string a un archivo "logger.lg".
    \begin{align} 
        \itb{log} ( \itb{strexp} )
    \end{align}
    \begin{lstlisting}
        # Logging
        int contador = 10;
        log("Loggeando... " & str(numero)) 
    \end{lstlisting}
    \section{Sintaxis de superficie}
    \subsection{Condicional}
    La cláusula \textbf{else} es opcional. \par
    \begin{center}
        \itb{if} ( \itb{boolexp} ) 
        \{ \itb{cmd} \} \itb{else} \{ \itb{cmd} \}
    \end{center}
    \begin{lstlisting}
        # Condicionales
        int edad = 20;
        if (edad > 18) {
            log("Puede beber!")
        } else {
            log("No puede beber!")
        }
    \end{lstlisting}
    \subsection{Bucles}
    En este caso contamos con bucles while y for.\par
    \begin{center}
        \itb{while} (\itb{boolexp}) \{\itb{cmd}\}
    \end{center}
    \begin{lstlisting}
        # Bucle while
        int counter = 0;
        int veces = 5;
        
        while (counter < veces) {
            counter = counter + 1
        }

    \end{lstlisting}
    \begin{center}
        \itb{for} (\itb{intexp} to \itb{intexp}) \{\itb{cmd}\}
    \end{center}
    \begin{lstlisting}
        # Bucle for
        int counter = 0;
        int veces = 5;
        
        while (0 to veces) {
            counter = counter + 1
        }

    \end{lstlisting}
    \newpage
    \subsection{Definición y asignación de variables}
    Podemos definir variables del tipo string e int.\par
    \begin{center}
        \itb{int} \itb{var} = \itb{intexp}
    \end{center}
    \begin{center}
        \itb{string} \itb{var} = \itb{strexp}
    \end{center}
    \begin{lstlisting}
        # Asignaciones
        int numero = 15;
        string saludo = "Buenos dias";
        numero = numero * 2;
        saludo = "Buenas noches"
    \end{lstlisting}

    \subsection{Operadores}
    Los operadores para expresiones enteras son multiplicación, división, suma, resta y modulo respectivamente.
    \begin{center}
        \itb{intexp} $\left[*|/|+|-|\%\right]$ \itb{intexp}
    \end{center}
    El operador para expresiones string es el concatenación.
    \begin{center}
        \itb{strexp} \& \itb{strexp}
    \end{center}

    \subsection{Grafos}
    La sentencia Graph indica que se creará un archivo de salida con un nombre especificado por el usuario. 
    \begin{center}
        \itb{GRAPH}(\itb{strexp}, \itb{intexp})$\left[\itb{intexp}\right]$
            \begin{center} \itb{cmd} \end{center}
        \itb{END}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \end{center}

    \itb{Nombre} indica, valga la redundancia, el nombre del archivo de output, \itb{size} establece la distancia entre nodos y
    \itb{msize} establece las dimensiones de la matriz interna donde se posicionan los nodos, por ejemplo, \itb{msize=4} establecerá
    una matriz interna de 4x4. \par
    \begin{center}
        \itb{GRAPH}(\itb{nombre}, \itb{size})$\left[\itb{msize}\right]$
    \end{center}

    \begin{lstlisting}
        # Grafos
        string nombre = "grafo1";
        # Crea un grafo con una matriz interna de 3x3
        GRAPH(nombre, 5)[3]
            ...
        END 
    \end{lstlisting}

    \subsection{Nodos y aristas}
    \bd{GraphDSL} permite la creación de nodos, estableciendo un identificador (tag), así como también 
    en que fila y columna insertarlo en la matriz interna.
    \begin{center}
        \itb{node}\{\itb{strexp}\}$<$\itb{intexp},\itb{intexp}$>$
    \end{center}
    \begin{lstlisting}
        string nombre = "";
        int max = 2;
        int counter = 0;
        int fila = 0;
        int columna = 0;
        GRAPH("test", 5)[max]
            while (fila < max) {
                while (columna < max){
                    # Construimos el id del nodo
                    nombre = "n" & str(counter);
                    # Insertamos el nodo en la matriz
                    node {nombre}<fila,columna>;
                    counter = counter + 1;
                    columna = columna + 1
                };
                # Reseteamos el contador de columnas
                columna = 0;
                fila = fila + 1
            }
        END
    \end{lstlisting}
    Para la creación de aristas se utiliza la sentencia edge. 
    \begin{center}
        \itb{edge} $\left[color\right] \left[tag\right]  \left[nodexp\right]$
    \end{center}
    Los parametros \itb{color} y \itb{tag} son opcionales y sirven para establecer respectivamente, 
    el color de la arista y el peso o tag de la misma.
    \begin{lstlisting}
        GRAPH("test", 5)[2]
            # Insertamos un nodo n1 en fila 0 columna 0
            node {"n1"}<0,0>;
            # Insertamos un nodo n1 en fila 0 columna 1
            node {"n2"}<0,1>;
            # Insertamos un bucle en el nodo n1 con peso 2
            edge "red" "2" {n1} -> {n1};
            # Insertamos una arista dirigida de n1 a n2 con peso 3
            edge "red" "3" {n1} -> {n2}
            # Ambas aristas seran de color rojo
        END
    \end{lstlisting}

    \newpage
    \section{Gramática}
% ------------------------------
%   INTEXP    
% ------------------------------
\begin{align*}
    intexp :&= \: intexp \: + \: term \\
    &| \: term \: -_{b} \: term \\
    term :&= \: term \: * \: factor \\
    &| \: term \: \div \: factor \\
    &| \: term \: \% \: factor \\
    factor :&= nat \: | \: var \: | \: -_{u}intexp\\
    &| \: \itb{len} \: strexp \\
    &| \: \itb{int} \: strexp \\
\end{align*}

% ------------------------------
%   BOOLEXP
% ------------------------------
\begin{align*}
    boolexp :&= boolexp \: \vee \: boolexp2 \\
    boolexp2 :&= boolexp2 \: \wedge \: boolexp3 \\
    boolexp3 :&= true \: | \: false \\
    &| \: \sim \: boolexp \\
    &| \: intexp \: = \: intexp \\
    &| \: intexp \: < \: intexp \\
    &| \: intexp \: > \: intexp \\
    &| \: intexp \: \ne \: intexp \\
    &| \: intexp \: \leq \: intexp \\
    &| \: intexp \: \geq \: intexp \\
    &| \: strexp \: = \: strexp \\
    &| \: strexp \: < \: strexp \\
    &| \: strexp \: > \: strexp \\
    &| \: strexp \: \ne \: strexp \\
    &| \: strexp \: \leq \: strexp \\
    &| \: strexp \: \geq \: strexp \\
\end{align*}

% ------------------------------
%   STREXP
% ------------------------------
\begin{align*}
    strexp :&= \: strexp \: \& \: strexp2 \\
    strexp2 :&= \: string \: | \: var \\
\end{align*}

% ------------------------------
%   CMD
% ------------------------------
\begin{align*}
    cmdparse :&= \: pass \\
    &| \: var \: = \: intexp \\
    &| \: var \: = \: strexp \\
    &| \: \itb{int} \: var \: = \: intexp \\
    &| \: \itb{string} \: var \: = \: strexp \\
    &| \: \itb{log} \: strexp \\
    &| \: \itb{graph} \: strexp \: intexp \: intexp \: cmdparse \: \itb{end}\\
    &| \: \itb{for} \: forp \: cmdparse \\
    &| \: \itb{while} \: boolexp \: cmdparse \\
    &| \: \itb{if} \: boolexp \: cmdparse \\
    &| \: \itb{if} \: boolexp \: \itb{else} \: cmdparse \\
    &| \: cmdparse \: ; \: cmdparse \\
    &| \: \itb{node} \: parseNodeCmd \\
    &| \: \itb{color} \: strexp \: nodexp \\
    &| \: \itb{edge} \: nodexp \\
    &| \: \itb{edge} \: strexp \: nodexp \\
    &| \: \itb{edge} \: strexp \: strexp \: nodexp \\
    parseNodeCmd :&= \: (strexp, intexp, intexp) \\
    forp :&= \: intexp \: \itb{to} \: intexp \\
\end{align*}

% ------------------------------
%   NODEXP
% ------------------------------
\begin{align*}
    nodexp :&= \: var \: | \: node \\ 
    &| \: nodexp \: \leftarrow \: nodexp \\
    &| \: nodexp \: \rightarrow \: nodexp \\
    &| \: nodexp \: \leftrightarrow \: nodexp \\
\end{align*}

\section{Semántica}
\begin{align*}
    % NVal
    \frac{}{(nv, \sigma) \Downarrow_{intexp} nv} NVal \quad
    % Var
    \frac{}{(v, \sigma) \Downarrow_{intexp} \sigma v} Var \quad
    % UMinus
    \frac{(e, \sigma)\Downarrow_{intexp} n}
         {(-_{u}e, \sigma) \Downarrow_{intexp} -n} UMinus \\~\\
    % Plus
    \frac{(e_0, \sigma) \Downarrow _{intexp}n_0 \quad (e_1,\sigma) \Downarrow_{intexp} n_1}
         {(e_0 + e_1, \sigma)\Downarrow _{intexp}n_0 + n_1} PLUS \qquad (\text{Analogamente para }-_b, \times) \\~\\
    % Div
    \frac{(e_0, \sigma) \Downarrow _{intexp}n_0 \quad (e_1,\sigma) \Downarrow_{intexp} n_1 \quad n_1\neq 0}
         {(e_0 \div e_1, \sigma)\Downarrow _{intexp}n_0 \div n_1} DIV \quad 
    % Int
    \frac{(e_0, \sigma)\Downarrow_{strexp} s_0}{(e_0,\sigma)\Downarrow_{intexp} {s_0}'} INT\\~\\ 
    % Mod
    \frac{(e_0, \sigma)\Downarrow_{intexp} n_0 \quad (e_1, \sigma)\Downarrow_{intexp} n_1}
         {(e_0 \% e_1, \sigma)\Downarrow _{intexp} n_0 \, \% \, n_1} Mod \quad
    % Len
    \frac{(e_0,\sigma)\Downarrow _{strexp} s_0}
         {(\textbf{len}\:e_0,\sigma)\Downarrow _{intexp} {s_0}'} Len\\~\\
    % SVal
    \frac{}{(nv, \sigma)\Downarrow _{strexp} nv} SVal \quad
    % SVar
    \frac{}{(v, \sigma)\Downarrow _{strexp}\sigma v} SVar \quad
    % Concat
    \frac{(e_0, \sigma) \Downarrow _{strexp}s_0 \quad (e_1,\sigma) \Downarrow_{strexp} s_1}
         {(e_0\,\&\,e_1, \sigma)\Downarrow _{strexp}s_0 \, \& \, s_1} Concat \\~\\
    % Str
    \frac{(e_0, \sigma) \Downarrow _{intexp}n_0}
         {(e_0, \sigma)\Downarrow _{strexp}{n_0}'} STR \quad
    % BVal
    \frac{}{(bv, \sigma)\Downarrow _{boolexp}bv} BVal \\~\\
    % Eq
    \frac{(e_0,\sigma)\Downarrow _{intexp} n_0 \quad (e_1,\sigma)\Downarrow _{intexp} n_1}
         {(e_0 = e_1, \sigma)\Downarrow _{boolexp} n_0 = n_1} Eq \quad (\text{Analogamente para }\; <, \;>,\;>=,\;<=\text{ y strexp}) \\~\\
    % Not
    \frac{(p,\sigma)\Downarrow _{boolexp} b}
         {(\neg p, \sigma)\Downarrow _{boolexp} \neg b} Not \quad 
    % Or
    \frac{(p_0,\sigma)\Downarrow _{boolexp} b_0 \quad (p_1,\sigma)\Downarrow _{boolexp} b_1}
         {(p_0 \vee p_1, \sigma)\Downarrow _{boolexp} b_0 \vee b_1} OR \quad (\text{Analogamente para }\wedge) \\~\\
    % Assign
    \frac{(e,\sigma)\Downarrow _{intexp} n}
         {(v:=e,\sigma) \curly (\textbf{pass},[\sigma|v:n])} Assign \quad (\text{Analogamente para strexp}) \\~\\
    % Def
    \frac{(e,\sigma)\Downarrow _{intexp} n}
         {(\textbf{int}\:v:=e,\sigma) \curly (\textbf{pass},[\sigma|v:n])} Def \quad 
    % DefStr
    \frac{(e,\sigma)\Downarrow _{strexp} s}
         {(\textbf{string}\:v:=e,\sigma) \curly (\textbf{pass},[\sigma|v:s])} DefStr \\~\\
    % Seq
    \frac{}{(\textbf{pass};c_1,\sigma) \curly (c_1,\sigma)} Seq_1 \quad 
    % Seq2
    \frac{(c_0,\sigma) \curly ({c_0}',{\sigma}')}
         {(c_0;c_1,\sigma) \curly ({c_0}';c_1,{\sigma}')} Seq_2 \\~\\
    % Log
    \frac{(e,\sigma)\Downarrow _{strexp} s_0}
         {(\textbf{log} \: e,\sigma) \overset{n!}{\curly} (\textbf{pass},\sigma)} Log \quad
    % If1
    \frac{(p,\sigma) \Downarrow _{boolexp} true}
         {(\textbf{if} \: p \: \textbf{then} \: c_0,\sigma) \curly (c_0,\sigma)}If_1 \quad 
    % If2
    \frac{(p,\sigma)\Downarrow _{boolexp} false}
         {(\textbf{if} \: p \: \textbf{then}\: c_0,\sigma) \curly (\textbf{pass},\sigma)}If_2 \\~\\
\end{align*}
\newpage
\begin{align*}
    % IfElse1
    \frac{(p,\sigma)\Downarrow _{boolexp} true}
         {(\textbf{if}\: p\: \textbf{then}\: c_0\: \textbf{else}\: c_1,\sigma) \curly (c_0,\sigma)}IfElse_1 \quad
    % IfElse2
    \frac{(p,\sigma)\Downarrow _{boolexp} false}
         {(\textbf{if}\: p\: \textbf{then}\: c_0\: \textbf{else}\: c_1,\sigma) \curly (c_1,\sigma)}IfElse_2 \\~\\
    % For
    \frac{(e_0,\sigma) \Downarrow _{intexp} n_0 \quad (e_1,\sigma)\Downarrow _{intexp} n_1}
         {(\textbf{for}\: e_0 \: \textbf{to} \: e_1 \: c_0,\sigma) \curly (\textbf{if}\: n_0 \: \ne \: n_1 \: \textbf{then} \: (c_0;\textbf{for} \: (n_0 + 1) \: \textbf{to}\: n_1 \: c_0) \:\textbf{else}\: \textbf{pass},\sigma)}For \\~\\    
    % While
    \frac{(p,\sigma) \Downarrow _{boolexp}}
         {(\textbf{while}\: p_0 \: c_0,\sigma) \curly (\textbf{if}\: p \: \textbf{then} \: (c_0;\textbf{while} \: p \: c_0) \:\textbf{else}\: \textbf{pass},\sigma)}While    \\~\\      
    % FALTA AGREGAR LA SEMANTICA PARA NODEXP
    % Node
    \frac{(e_0,\sigma) \Downarrow _{strexp} s_0 \quad (e_1, \sigma) \Downarrow _{intexp} n_0 \quad (e_2, \sigma) \Downarrow _{intexp} n_1}
         {(\textbf{node} \: e_0 \: e_1 \: e_2, \sigma) \curly (\textbf{pass}, [\sigma | \textbf{node} \: s_0 \: n_0 \: n_1])}Node   \\~\\
    % Edge1
    \frac{(e_0, \sigma) \Downarrow _{nodexp} n_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_1}
         {(\textbf{edge} \: e_0 \: e_1, \sigma) \curly (\textbf{pass}, [\sigma | \textbf{edge} \: n_0 \: n_1])}Edge_1 \\~\\
    % Edge2
    \frac{(e_0,\sigma) \Downarrow _{strexp} s_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_0 \quad (e_2, \sigma) \Downarrow _{nodexp} n_1}
         {(\textbf{edge} \: e_0 \: e_1 \: e_2, \sigma) \curly (\textbf{pass}, [\sigma | \textbf{edge} \: s_0 \: n_0 \: n_1])}Edge_2 \\~\\
    % Edge3
    \frac{(e_0,\sigma) \Downarrow _{strexp} s_0 \quad (e_1,\sigma) \Downarrow _{strexp} s_1 \quad (e_2, \sigma) \Downarrow _{nodexp} n_0 \quad (e_3, \sigma) \Downarrow _{nodexp} n_1}
         {(\textbf{edge} \: e_0 \: e_1 \: e_2 \: e_3, \sigma) \curly (\textbf{pass}, [\sigma | \textbf{edge} \: s_0 \: s_1 \: n_0 \: n_1])}Edge_3 \\~\\
    % Color 
    \frac{(e_0, \sigma) \Downarrow _{strexp} s_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_0}
         {(\textbf{color} \: e_0 \: e_1, \sigma) \curly (\textbf{pass}, [\sigma | n_0 : e_0])}Color \\~\\
    % EdgeOp
    \frac{(e_0, \sigma) \Downarrow _{nodexp} n_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_1  }
         {(e_0 \: \leftarrow \: e_1, \sigma) \Downarrow _{nodexp} n_0 \: \leftarrow \: n_1} EdgeOp_1 \quad 
    % EdgeOp2 
    \frac{(e_0, \sigma) \Downarrow _{nodexp} n_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_1}
         {(e_0 \: \rightarrow \: e_1, \sigma) \Downarrow _{nodexp} n_0 \: \rightarrow \: n_1} EdgeOp_2 \\~\\
    % EdgeOp3 
    \frac{(e_0, \sigma) \Downarrow _{nodexp} n_0 \quad (e_1, \sigma) \Downarrow _{nodexp} n_1}
         {(e_0 \: \leftrightarrow \: e_1, \sigma) \Downarrow _{nodexp} n_0 \: \leftrightarrow \: n_1} EdgeOp_3
\end{align*}

\end{document}